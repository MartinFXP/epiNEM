---
title: "Epistatic Nested Effects Models
- Inferring mixed epistatis from indirect measurements of knockout screens."
author: "Madeline Diekmann & Martin Pirkl"
date: "`r Sys.Date()`"
output: BiocStyle::pdf_document
vignette: >
    %\VignetteIndexEntry{epiNEM}
    %\VignetteEngine{knitr::rmarkdown}
    %\VignetteEncoding{UTF-8}
---
## Introduction

The method in this package is an extension of the classic Nested Effects
Models provided in the package \emph{nem}. Nested Effects Models is a pathway
reconstruction method, which takes into account effects of downstream genes.
Those effects are observed for every knockout of an upstream pathway gene, and
the nested structure of observed effects can then be used to reconstruct the
pathway structure.
However, classic Nested Effects Models do not account for double knockouts.
In this package \emph{epiNEM}, one additional layer of complexity is added.
For every two genes, acting on one gene together, the relationship is evaluated
and added to the model as a logical gate. Genetic relationships are represented
by the logics OR (no relationship), AND (functional overlap),
NOT (masking or inhibiting) and XOR (mutual prevention from acting on gene C).
Please see the references for a more detailed description of NEMs and epiNEMs.

Simulation and application results are imported from pre-calculated data sets
to shorten the runtime of this vignette.

## Loading epiNEM

```{r}
source("https://bioconductor.org/biocLite.R")

biocLite("devtools")

library(devtools)

biocLite("rmarkdown")

library(rmarkdown)

library(epiNEM)
```

## Quick start

The data should be in the form of binary effects stemming from
knock-out data including single and double perturbations with
effect reporters, e.g. genes, as rows and perturbations as columns.
A one in row i and column j denotes an effect of reporter i for
perturbation j. These effects are usually derived from comparing
control/wild-type experiments with respective perturbation experiments
(e.g. differential expression with edgeR).
The binary data is the main input for the epiNEM function, which
contains the inference algorithm to estimate the underlying network
structure of the data. For up to four signalling genes (=different
perturbation targets) exhaustive search is available. For five or
more a greedy search is implemented as an alternative.

```{r, fig.width = 5, fig.height = 5}
data <- matrix(sample(c(0,1), 100*4, replace = TRUE), 100, 4)
colnames(data) <- c("A", "A.B", "B", "C")
rownames(data) <- paste("E", 1:100, sep = "_")
print(head(data))
res <- epiNEM(data, method = "exhaustive")
plot(res)
```

The plot shows the inferred network with the signaling genes (bright red),
the inferred logic (green) and attachment of the number of effect
reporters (grey).

Alternatively the input can be a larger matrix with single and double
knock-downs. EpiNEM can perform a systematic analysis to identify most
likely modulators for a signaling gene pair of a double knock-down.

```{r, fig.width = 10, fig.height = 10}
data <- matrix(sample(c(0,1), 100*9, replace = TRUE), 100, 9)
colnames(data) <- c("A.B", "A.C", "B.C", "A", "B", "C", "D", "E", "G")
rownames(data) <- paste("E", 1:100, sep = "_")
res <- epiScreen(data)
plot(res)
plot(res, global = FALSE, ind = 1)
```

If the "global" parameter is set to FALSE, detailed results are plotted
for each or a specific ("ind" parameter) pair of a double knock-down.

The results (logics) of the knockout screens have been annotated
according to the following legend of effects (black), where the
x-axis denotes the gene and the y-axis denotes the type of knock-out:

```{r, warning=FALSE, fig.width = 9, fig.height=5}
epiAnno()
```

## Simulations

We compare epiNEM to original NEMs, Boolean Nested Effects Models (B-NEM,
[link](https://github.com/MartinFXP/B-NEM)),
Aracne and the PC algorithm for 100 four node networks and respective data
experiencing different levels of noise. The evaluation is done by accounting
for the accuracy of discovered edges and in the case of B-NEM and epiNEM also
the truth tables and logical gates.

```{r}
## install_github("MartinFXP/B-NEM"); library(bnem)

library(nem)

library(minet)

library(pcalg)

runs <- 100

noiselvls <- c(0.01, 0.025, 0.05, 0.1, 0.2, 0.3, 0.4, 0.5)

random <- list(FPrate = 0.1, FNrate = noiselvls,
               single = 4, double = 1, reporters = 100, replicates = 3)

do <- c("n", "p", "a", "e", "b")

maxTime <- FALSE

forcelogic <- TRUE

epinemsearch <- "greedy"

nIterations <- 3

bnemsearch <- "genetic"
```

We simulate code based on a ground truth and infer an optimal network
with all aforementioned methods solely based on the data.
The B-NEM package is necessary to run the full simulation:
[link](https://github.com/MartinFXP/B-NEM).

```{r, eval=FALSE}
simresults <- SimEpiNEM(runs, do, random, maxTime, forcelogic,
epinemsearch, bnemsearch, nIterations)

sim <- simresults
```

We boxplot running time, accuracy for the inferred edges,
logical gates and expected data (truth table) for all five respectively
two methods.

```{r, fig.width = 7, fig.height = 7}
data(sim)

plot(sim)
```

The plot shows that as expected B-NEM is the slowest followed by epiNEM,
while NEM, ARACNE and the PC algorithm are much faster. However, the last
three can not derive any logics in the network structure. epiNEM and
B-NEM show almost equally high accuracy of inferred edges and truth tables
(expected data). However, epiNEM reaches a much higher accuracy for inferred
logic gates, which is due to the much higher degree of equivalent network
structures in the case of B-NEM.

## Yeast knockout screens

In this section we analyse previously published yeast knockout
screens. The screens consist of gene expression data derived from
double and single knockout mutants. We use epiNEM on each double
mutant combined with each single mutant.

### Wageningen et al., 2010

The first knock-out screen is from van Wageningen et al., 2010 and
was created to investigate relationships between phosphorylation based pathways.

The first figure shows the global distribution of the top scoring
logics we identified.

Each of the following figures visualizes the top scoring single
knock-out or modulator
for a specific double knock-out pair. The x-axis corresponds to the
ranks of the single knock-outs and the y-axsis to the likelihood for
each triple (double plus single knock-outs).

We load and preprocess the data set.

```{r}
file <- paste("http://www.holstegelab.nl/",
              "publications/sv/signaling_redundancy/downloads/DataS1.txt",
              sep = "")

data <- read.delim(file)

dataM <- data[-(1:2), (1+(1:(324/2))*2)]

dataP <- data[-(1:2), (2+(1:(324/2))*2)]

dataM <- dataM[-1, ]

dataP <- dataP[-1, ]

dataM <- apply(dataM, c(1,2), as.numeric)

dataP <- apply(dataP, c(1,2), as.numeric)

dataBin <- dataM

sig <- 0.05

cutoff <- log2(1.7)

dataBin[which(dataP < sig & dataP > 0 & abs(dataM) >= cutoff)] <- 1

dataBin[which(dataP >= sig | dataP == 0 | abs(dataM) < cutoff)] <- 0

dataBin <- dataBin[-which(apply(dataBin, 1, max) == 0), ]

dataBinWag <- dataBin

colnames(dataBin) <- gsub(".del.vs..wt", "", colnames(dataBin))

colnames(dataBin) <- gsub(".del", "", colnames(dataBin))

doubles <- colnames(dataBin)[grep("\\.", colnames(dataBin))]

if (length(grep("vs", doubles)) > 0) {
    doubles <- sort(doubles[-grep("vs", doubles)])
} else { doubles <- sort(doubles) }

doubles.genes <- unique(unlist(strsplit(doubles, "\\.")))

if (length(grep("\\.", colnames(dataBin))) > 0) {
    singles <- colnames(dataBin)[-grep("\\.", colnames(dataBin))]
} else { singles <- sort(singles) }

singles <- unique(sort(singles))
```

We apply epiNEM to all triples and infer logics and calculate the
log-likelihood.

```{r, eval=FALSE}
wagscreen <- epiScreen(dataBin)
```

The following plot shows the global distribution of the inferred logical gates
for all pairs. The single modulators are on the y-axis and the double
knock-out pairs are on the x-axis.

```{r, fig.width = 8, fig.height = 4}
palette(c("#4444cc", "#77aa77", "#009933",
"#ff0000", "#dd8811", "#aa44bb", "#999900"))

data(wageningen)

doubles <- wageningen$doubles

dataWag <- wageningen$dataWag

wagscreen <- wageningen

## clean up the results:

wagscreen$doubles <- wagscreen$doubles[-grep("fus3|ptp2.ptc2",
                                             wagscreen$doubles)]

wagscreen$dataWag <- wagscreen$dataWag[, -grep("fus3|ptp2.ptc2",
                                               colnames(wagscreen$dataWag))]

wagscreen$ll <- wagscreen$ll[, -grep("fus3|ptp2.ptc2", colnames(wagscreen$ll))]

wagscreen$logic <- wagscreen$logic[, -grep("fus3|ptp2.ptc2",
                                           colnames(wagscreen$logic))]

plot(wagscreen)
```

We also plot the significant results for every explicit triple with
log-likelihoods on the y-axis and ranked triples on the x-axis. The
"ind" parameter, if set, selects a subset.

```{r}
plot(wagscreen, global = FALSE, ind = 3)
```

### Sameith et al., 2015

The second knock-out screen by Sameith et al., 2015 was created to
investigate growth based genetic interactions.

Again we preprocess the data.

```{r}
file <- paste("http://www.holstegelab.nl/",
              "publications/GSTF_geneticinteractions/",
              "downloads/del_mutants_limma.txt", sep = "")

data <- read.delim(file)

data <- apply(data, c(1,2), as.character)

dataM <- data[-1, which(data[1, ] %in% "M")]

dataM <- apply(dataM, c(1,2), as.numeric)

dataP <- data[-1, which(data[1, ] %in% "p.value")]

dataP <- apply(dataP, c(1,2), as.numeric)

dataBin <- dataM

sig <- 0.01

cutoff <- log2(1.5)

dataBin[which(dataP < sig & dataP > 0 & abs(dataM) >= cutoff)] <- 1

dataBin[which(dataP >= sig | dataP == 0 | abs(dataM) < cutoff)] <- 0

dataBin <- dataBin[-which(apply(dataBin, 1, max) == 0), ]

colnames(dataBin) <- gsub("\\.\\.\\.", "\\.", colnames(dataBin))

doubles <- colnames(dataBin)[grep("\\.", colnames(dataBin))]

if (length(grep("vs", doubles)) > 0) {
    doubles <- sort(doubles[-grep("vs", doubles)])
} else { doubles <- sort(doubles) }

doubles.genes <- unique(unlist(strsplit(doubles, "\\.")))

if (length(grep("\\.", colnames(dataBin))) > 0) {
    singles <- colnames(dataBin)[-grep("\\.", colnames(dataBin))]
} else { singles <- sort(singles) }

singles <- unique(sort(singles))
```

We apply epiNEM to screen all triples from double and single
knock-out combinations.

```{r, eval=FALSE}
samscreen <- epiScreen(dataBin)
```

Again, we plot the global distribution of logics followed by
the explicit results for every triple.

```{r, fig.width = 8, fig.height = 4}
data(sameith)

doubles <- sameith$doubles

dataSam <- sameith$dataSam

samscreen <- sameith

plot(samscreen)

plot(samscreen, global = FALSE, ind = c(2,4))
```

We plot the densities of the string-db interaction scores of our
identified modulators and a random draw for any pair included in
the data sets to visualize the significance
of the interaction identified by epiNEM.

We load the STRING library and download data base information
for the yeast organism.

```{r, fig.width = 8, fig.height = 4}
source("https://bioconductor.org/biocLite.R")

biocLite("STRINGdb")

library(STRINGdb)

get_STRING_species(version="10", species_name=NULL)[26, ] # 4932

string_db <- STRINGdb$new( version="10", species=4932, score_threshold=0,
                          input_directory="~/")

llmat <- wageningen$ll

logicmat <- wageningen$logic

string.scores <- list()

string.names <- character()
```
	
We retrieve unique data base name and score information for the
genes included in the data sets.

```{r, eval=FALSE}
for (i in 1:ncol(llmat)) {
    if (sum(!(llmat[, i] %in% c(0,-Inf))) > 0) { 
        top30 <- llmat[, i]
        top30[which(top30 == 0)] <- -Inf
        top30 <- top30[which(!(llmat[, i] %in% c(0,-Inf)))]
        top30 <- top30[order(top30,decreasing = TRUE)[1:min(30, sum(!(llmat[, i]
            %in% c(0,-Inf))))]]

        doubles <- unlist(strsplit(colnames(llmat)[i], "\\."))

        for (j in names(top30)) {
            tmp <- string_db$get_interactions(string_db$mp(c(doubles[1], j)))
            string.scores <- c(string.scores, tmp$combined_score)
            string.names <- c(string.names, paste(sort(c(doubles[1], j)),
                                                  collapse = "_"))
            tmp <- string_db$get_interactions(string_db$mp(c(doubles[2], j)))
            string.scores <- c(string.scores, tmp$combined_score)
            string.names <- c(string.names, paste(sort(c(doubles[2], j)),
                                                  collapse = "_"))
        }

    } else {
        next()
    }
}
```
	
We plot the densities of the distributions of the random pair
scores (blue) and the scores of a pair from the triplets by epiNEM (pink).
Additionally we calculate, if the difference between the two score
distributions is significant (Mann-Whitney test).

```{r, fig.width = 8, fig.height = 5}
data(wageningen_string)

string.scores <- wageningen_string$string.scores
string.names <- wageningen_string$string.names

tmp <- string_db$get_interactions(
    string_db$mp(unique(unlist(strsplit(colnames(dataWag), "\\.")))))

stsc <- unlist(string.scores)

denspval <- wilcox.test(stsc, unlist(tmp$combined_score),
                        alternative = "greater")$p.value

for (i in 100:1) {

    if (denspval < 10^(-i)) {

        denspval <- paste("< ", 10^(-i), sep = "")

    } 

}

plot(density(stsc), col = "#00000000",
     ylim = c(0, max(c(max(density(stsc)$y),
                       max(density(unlist(tmp$combined_score))$y)))),
     main = paste("Mann-Whitney test p-value ", denspval, sep = ""), xlab = "",
     cex.main = 1.5)
polygon(density(stsc), col = "#ff000066")

lines(density(unlist(tmp$combined_score)), col = "#00000000")
polygon(density(unlist(tmp$combined_score)), col = "#00ffff66")

llmat <- sameith$ll

logicmat <- sameith$logic

string.scores2 <- list()

string.names2 <- character()
```
```{r, eval=FALSE}
for (i in 1:ncol(llmat)) {

    if (sum(!(llmat[, i] %in% c(0,-Inf))) > 0) { 
        top30 <- llmat[, i]
        top30[which(top30 == 0)] <- -Inf
        top30 <- top30[which(!(llmat[, i] %in% c(0,-Inf)))]
        top30 <- top30[order(top30, decreasing = TRUE)
                       [1:min(30, sum(!(llmat[, i] %in% c(0,-Inf))))]]

        doubles <- unlist(strsplit(colnames(llmat)[i], "\\."))

        for (j in names(top30)) {
            tmp <- string_db$get_interactions(string_db$mp(c(doubles[1], j)))
            string.scores2 <- c(string.scores2, tmp$combined_score)
            string.names2 <- c(string.names2, paste(sort(c(doubles[1], j)),
                                                    collapse = "_"))
            tmp <- string_db$get_interactions(string_db$mp(c(doubles[2], j)))
            string.scores2 <- c(string.scores2, tmp$combined_score)
            string.names2 <- c(string.names2, paste(sort(c(doubles[2], j)),
                                                    collapse = "_"))
        }

    } else {
        next()
    }

}
```
```{r, fig.width = 8, fig.height = 5}
data(sameith_string)

string.scores2 <- sameith_string$string.scores2
string.names2 <- sameith_string$string.names2

tmp <- string_db$get_interactions(
    string_db$mp(unique(unlist(strsplit(colnames(dataSam), "\\.")))))

stsc <- unlist(string.scores2)

denspval <- wilcox.test(stsc, unlist(tmp$combined_score),
                        alternative = "greater")$p.value

for (i in 100:1) {

    if (denspval < 10^(-i)) {

        denspval <- paste("< ", 10^(-i), sep = "")

    } 

}

plot(density(stsc), col = "#00000000",
     ylim = c(0, max(c(max(density(stsc)$y),
                       max(density(unlist(tmp$combined_score))$y)))),
     main = paste("Mann-Whitney test p-value ", denspval, sep = ""), xlab = "",
     cex.main = 1.5)
polygon(density(stsc), col = "#ff000066")

lines(density(unlist(tmp$combined_score)), col = "#00000000")
polygon(density(unlist(tmp$combined_score)), col = "#00ffff66")
```

In addition to STRINGdb interaction scores, we have a look at enriched
GO terms for each set of identified modulators. For this analysis we
   again use the STRINGdb package.

We generate a matrix visualizing the KEGG pathway enrichment for all
pairs for the van Wageningen and the Sameith data sets.

```{r, eval=FALSE}
## van Wageningen:

## STRINGdb$help("get_enrichment")

string_db$set_background(
    string_db$mp(unique(c(unlist(strsplit(colnames(wagscreen$ll), "\\.")),
                          rownames(wagscreen$ll)))))

golist <- list()

for (i in 1:ncol(wagscreen$ll)) {
    golist[[i]] <- string_db$get_enrichment(string_db$mp(unique(
        c(unlist(strsplit(colnames(wagscreen$ll)[i], "\\.")),
          rownames(wagscreen$ll)[which(!(wagscreen$logic[, i] %in%
                                         c("NOINFO", "NOEPI")))]))),
        category = "KEGG", methodMT = "fdr", iea = TRUE)
}
```
```{r, fig.width = 8, fig.height = 7}
data(wageningen_GO)

golist <- wageningen_GO$golist

goterms <- character()

for (i in 1:length(golist)) {

    if (i %in% c(5,8)) { next() }

    goterms <- c(goterms,
                 golist[[i]]$term_description[which(golist[[i]]$pvalue_fdr
                                                    < 1)])

}

gomat <- matrix(NA, length(unique(goterms)), ncol(wagscreen$ll))

rownames(gomat) <- sort(unique(goterms))
colnames(gomat) <- colnames(wagscreen$ll)

## there is a strong cutoff for fdr >= 0.05 !?! realy??? no!

for (i in 1:ncol(wagscreen$ll)) {

    gotmp <- golist[[i]]
    gotmp <- gotmp[order(gotmp$term_description), ]

    gomat[which(rownames(gomat) %in% golist[[i]]$term_description), i] <-
        golist[[i]][which(golist[[i]]$term_description %in% rownames(gomat)), 4]

}

if (nrow(gomat) > 20) {
    rownames(gomat) <- NULL
}

gomat[which(is.na(gomat) == TRUE)] <- -max(gomat, na.rm = TRUE)

## gomat <- gomat[, -grep("fus3|ptp2.ptc2", colnames(gomat))]

HeatmapOP(gomat, breaks = seq(-max(gomat),max(gomat), length = 100),
          bordercol = "transparent",
          main = "", sub = "",
          xrot = 45, col = "RdYlBu")
```
```{r, eval=FALSE}
## Sameith:

string_db$set_background(string_db$mp(unique(c(unlist(
    strsplit(colnames(sameith$ll), "\\.")), rownames(sameith$ll)))))

golist2 <- list()

for (i in 1:ncol(sameith$ll)) {
    golist2[[i]] <- string_db$get_enrichment(string_db$mp(
        unique(c(unlist(strsplit(colnames(sameith$ll)[i], "\\.")),
                 rownames(sameith$ll)
                 [which(!(sameith$logic[, i] %in% c("NOINFO", "NOEPI")))]))),
        category = "KEGG", methodMT = "fdr", iea = TRUE)
}
```
```{r, fig.width = 8, fig.height = 7}
data(sameith_GO)

golist2 <- sameith_GO$golist

goterms <- character()

for (i in 1:length(golist2)) {

    goterms <-
        c(goterms,
          golist2[[i]]$term_description[which(golist2[[i]]$pvalue_fdr < 0.1)])

}

gomat <- matrix(NA, length(unique(goterms)), ncol(sameith$ll))

rownames(gomat) <- sort(unique(goterms))
colnames(gomat) <- colnames(sameith$ll)

for (i in 1:ncol(sameith$ll)) {

    gotmp <- golist2[[i]]
    gotmp <- gotmp[order(gotmp$term_description), ]

    gomat[which(rownames(gomat) %in% golist2[[i]]$term_description), i] <-
        golist2[[i]][which(golist2[[i]]$term_description %in%
                           rownames(gomat)), 4]

}

if (nrow(gomat) > 20) {
    rownames(gomat) <- NULL
}

gomat[which(is.na(gomat) == TRUE)] <- -max(gomat, na.rm = TRUE)

colnames(gomat) <- tolower(colnames(gomat))

HeatmapOP(gomat, breaks = seq(-max(gomat), max(gomat), length = 100),
          bordercol = "transparent",
          main = "", sub = "",
          xrot = 45, cexCol = 0.5, col = "RdYlBu")

## HeatmapOP(cor(gomat), breaks = seq(0, 1, length=100), dendrogram = "col")
```

The final analysis is similar to the STRINGdb interaction scores. However,
instead of these we use Graph-based GO term similarity scores. Additionally,
we do not compare 

```{r}
library(GOSemSim)
library(AnnotationHub)
library(org.Sc.sgd.db)

ystGO <- godata("org.Sc.sgd.db", ont = "BP",
                keytype = keytypes(org.Sc.sgd.db)[11], computeIC = FALSE)

```	
```{r, eval=FALSE}
GOepi <- numeric()

for (i in 1:ncol(wagscreen$ll)) {
    if (i %in% grep("fus3|ptp2.ptc2", colnames(wagscreen$ll))) { next() }
    pair <- toupper(unlist(strsplit(colnames(wagscreen$ll)[i], "\\.")))
    for (j in which(!is.infinite(wagscreen$ll[, i]) == TRUE &
                    wagscreen$ll[, i] != 0)) {
        tmp <- clusterSim(pair, toupper(rownames(wagscreen$ll)[j]),
                       semData = ystGO, combine = "max")
        if (!is.na(tmp[1])) {
            GOepi <- c(GOepi, tmp)
        }
    }
}

GOall <- numeric()

for (i in colnames(wagscreen$ll)) {
    pair <- toupper(unlist(strsplit(i, "\\.")))
    for (j in rownames(wagscreen$ll)) {
        tmp <- clusterSim(pair, toupper(j), semData = ystGO, combine = "max")
        if (!is.na(tmp[1])) {
            GOall <- c(GOall, tmp)
        }
    }
}
```
```{r}
data(wageningen_GO)

GOepi <- wageningen_GO$epi
GOall <- wageningen_GO$all

denspval <- wilcox.test(GOepi, GOall, alternative = "greater")$p.value

for (i in 100:1) {
    if (i <= 2) {
        for (j in 1:9) {
            if (denspval < j*10^(-i)) {
                denspval <- paste("< ", j*10^(-i), sep = "")
            }
        }
    } else {
        if (denspval < 10^(-i)) {
            denspval <- paste("< ", 10^(-i), sep = "")
        }
    }
}

plot(density(GOepi), col = "#00000000",
     ylim = c(0, max(c(max(density(GOepi)$y),
                       max(density(unlist(GOall))$y)))),
     main = paste("Mann-Whitney test p-value ", denspval, sep = ""), xlab = "",
     cex.main = 1.5)
polygon(density(GOepi), col = "#ff000066")

lines(density(unlist(GOall)), col = "#00000000")
polygon(density(unlist(GOall)), col = "#00ffff66")
```	
```{r, eval=FALSE}
GOepi2 <- numeric()

for (i in 1:ncol(samscreen$ll)) {
    if (i %in% grep("fus3|ptp2.ptc2", colnames(samscreen$ll))) { next() }
    pair <- toupper(unlist(strsplit(colnames(samscreen$ll)[i], "\\.")))
    for (j in which(!is.infinite(samscreen$ll[, i]) == TRUE &
                    samscreen$ll[, i] != 0)) {
        tmp <- clusterSim(pair, toupper(rownames(samscreen$ll)[j]),
                       semData = ystGO, combine = "max")
        if (!is.na(tmp[1])) {
            GOepi2 <- c(GOepi2, tmp)
        }
    }
}

GOall2 <- numeric()

for (i in colnames(samscreen$ll)) {
    pair <- toupper(unlist(strsplit(i, "\\.")))
    for (j in rownames(samscreen$ll)) {
        tmp <- clusterSim(pair, toupper(j), semData = ystGO, combine = "max")
        if (!is.na(tmp[1])) {
            GOall2 <- c(GOall2, tmp)
        }
    }
}
```
```{r}
data(sameith_GO)

GOepi2 <- sameith_GO$epi
GOall2 <- sameith_GO$all

denspval <- wilcox.test(GOepi2, GOall2, alternative = "greater")$p.value

 for (i in 100:1) {
     if (i <= 2) {
         for (j in 1:9) {
             if (denspval < j*10^(-i)) {
                 denspval <- paste("< ", j*10^(-i), sep = "")
             }
         }
     } else {
         if (denspval < 10^(-i)) {
             denspval <- paste("< ", 10^(-i), sep = "")
         }
     }
}

plot(density(GOepi2), col = "#00000000",
     ylim = c(0, max(c(max(density(GOepi2)$y),
                       max(density(unlist(GOall2))$y)))),
     main = paste("Mann-Whitney test p-value ", denspval, sep = ""), xlab = "",
     cex.main = 1.5)
polygon(density(GOepi2), col = "#ff000066")

lines(density(unlist(GOall2)), col = "#00000000")
polygon(density(unlist(GOall2)), col = "#00ffff66")
```



	
```{r}
sessionInfo()
```

*__Reference:__*

Martin Pirkl, Madeline Diekmann, Marlies van der Wees, Niko Beerenwinkel,
Holger Fröhlich, Florian Markowetz. Inferring Modulators of Genetic
Interactions with Epistatic Nested Effects Models. submitted.

Robinson MD, McCarthy DJ, Smyth GK. edgeR: a Bioconductor package for
differential expression analysis of digital gene expression data.
Bioinformatics. 2010;26(1):139-140. doi:10.1093/bioinformatics/btp616.

Margolin AA, Nemenman I, Basso K, Wiggins C, Stolovitzky G, {Dalla Favera} R,
et~al. ARACNE: an algorithm for the reconstruction of gene regulatory networks
in a mammalian cellular context. BMC Bioinformatics. 2006;7 Suppl 1:S7.

Kalisch M, B\"{u}hlmann P. Estimating High-Dimensional Directed Acyclic Graphs
with the PC-Algorithm. J Mach Learn Res. 2007;8.

Markowetz F, Bloch J, Spang R. Non-transcriptional pathway features
reconstructed from secondary effects of RNA interference. Bioinformatics.
2005;21(21):4026--4032.

Pirkl M, Hand E, Kube D, Spang R. Analyzing synergistic and non-synergistic
interactions in signalling pathways using Boolean Nested Effect Models.
Bioinformatics. 2016;32(6):893--900.

van Wageningen S, Kemmeren P, Lijnzaad P, Margaritis T, Benschop JJ,
de Castro IJ, et~al. Functional overlap and regulatory links shape genetic
interactions between signaling pathways. Cell. 2010 Dec;143(6):991--1004.

Sameith K, Amini S, Groot~Koerkamp MJA, van Leenen D, Brok M, Brabers N, et~al.
A high-resolution gene expression atlas of epistasis between gene-specific
transcription factors exposes potential mechanisms for genetic interactions.
BMC biology. 2015 Dec;13:112.

Guangchuang Yu, Fei Li, Yide Qin, Xiaochen Bo, Yibo Wu, Shengqi Wang;
GOSemSim: an R package for measuring semantic similarity among GO terms
and gene products. Bioinformatics 2010; 26 (7): 976-978.
doi: 10.1093/bioinformatics/btq064
