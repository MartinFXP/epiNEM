---
title: "Epistatic Nested Effects Models
- Inferring mixed epistatis from indirect measurements of knockout screens."
author: "Madeline Diekmann & Martin Pirkl"
date: "`r Sys.Date()`"
output: BiocStyle::pdf_document
vignette: >
    %\VignetteIndexEntry{epiNEM}
    %\VignetteEngine{knitr::rmarkdown}
    %\VignetteEncoding{UTF-8}
---
## Introduction

The method in this package is an extension of the classic Nested Effects
Models provided in the package \emph{nem}. Nested Effects Models is a pathway
reconstruction method, which takes into account effects of downstream genes.
Those effects are observed for every knockout of an upstream pathway gene, and
the nested structure of observed effects can then be used to reconstruct the
pathway structure.
However, classic Nested Effects Models do not account for double knockouts.
In this package \emph{epiNEM}, one additional layer of complexity is added.
For every two genes, acting on one gene together, the relationship is evaluated
and added to the model as a logical gate. Genetic relationships are represented
by the logics OR (no relationship), AND (functional overlap),
NOT (masking or inhibiting) and XOR (mutual prevention from acting on gene C).
Please see the references for a more detailed description of NEMs and epiNEMs.

Simulation and application results are imported from pre-calculated data sets
to shorten the runtime of this vignette.

## Loading epiNEM

```{r}
source("https://bioconductor.org/biocLite.R")

biocLite("devtools")

library(devtools)

biocLite("rmarkdown")

library(epiNEM)
```

## Quick start

You data should be in the form of binary effects stemming from
knock-out data including single and double perturbations with
effect reporters, e.g. genes, as rows and perturbations as columns.
A one in row i and column j denotes an effect of reporter i for
perturbation j. These effects are usually derived from comparing
control/wild-type experiments with respective perturbation experiments
(e.g. from edgeR or limma).
The binary data is the main imput for the epiNEM function, which
contains the inference algorithm to estimate the underlying network
structure of the data. For up to four signalling genes (=different
perturbation targets) exhautive search is available. For five or
more a greedy search is implemented as an alternative.


```{r}
data <- matrix(sample(c(0,1), 100*4, replace = TRUE), 100, 4)

colnames(data) <- c("A", "A.B", "B", "C")

rownames(data) <- paste("E", 1:100, sep = "_")

print(head(data))

res <- epiNEM(data, method = "exhaustive")

plot(res)
```

The plot shows the inferred network with the signaling genes (bright red),
the inferred logic (green) and attchment of effect reporters.

## Simulations

We compare epiNEM to original NEMs, Boolean Nested Effects Models (B-NEM,
[link](https://github.com/MartinFXP/B-NEM)),
Aracne and the PC algorithm for 100 four node networks and respective data
experiencing different levels of noise. The evaluation is done by accounting
for the accuracy of discovered edges and in the case of B-NEM and epiNEM also
the truth tables and logical gates.

```{r}
## install_github("MartinFXP/B-NEM"); library(bnem)

library(nem)

library(minet)

library(pcalg)

runs <- 100

noiselvls <- c(0.01, 0.025, 0.05, 0.1, 0.2, 0.3, 0.4, 0.5)

random <- list(FPrate = 0.1, FNrate = noiselvls,
               single = 4, double = 1, reporters = 100, replicates = 3)

do <- c("n", "p", "a", "e", "b")

popSize <- 100

maxTime <- FALSE

forcelogic <- TRUE

epinemsearch <- "greedy"

nIterations <- 3

bnemsearch <- "genetic"

logicgate <- matrix("", runs, length(noiselvls))

edgenr <- matrix(0, runs, length(noiselvls))
```

We simulate code based on a ground truth and infer a optimal network
with all aforementioned methods solely based on the data.
If you run this code, make sure to install the B-NEM package
from github: [link](https://github.com/MartinFXP/B-NEM).

```{r, eval=FALSE}
simresults <- SimEpiNEM(runs, do, random, maxTime, forcelogic,
                        epinemsearch, bnemsearch, nIterations)

sens <- simresults$sens
spec <- simresults$spec
sens2 <- simresults$sens2
spec2 <- simresults$spec2
logics <- simresults$logics
time <- simresults$time

```

We boxplot running time, accuracy for the inferred edges,
logical gates and expected data (truth table) for all five methods.

```{r, fig.width = 7, fig.height = 7}
data(sim)

sens <- sim$sens
spec <- sim$spec
sens2 <- sim$sens2
spec2 <- sim$spec2
logics <- sim$logics
time <- sim$time

colvec <- c(rep("orange", length(noiselvls)),
            rep("blue", length(noiselvls)),
            rep("darkgreen", length(noiselvls)),
            rep("brown", length(noiselvls)),
            rep("darkgrey", length(noiselvls)))

acc <- (sens + spec)/2

acc2 <- (sens2 + spec2)/2

m <- rbind(c(1,1), c(2,2), c(3,4))

layout(m)

timeframe <- as.data.frame(
    cbind(data.frame(epiNEM = time[1,,]),
          data.frame(BNEM = time[2,,]), data.frame(NEM = time[3,,]),
          data.frame(Cor = time[4,,]), data.frame(MI = time[5,,])))

colnames(timeframe) <- rep(noiselvls, 5)

boxplot(timeframe, col = colvec, main = "running time", ylab = "seconds")

abline(v=(1:(length(do)-1)*length(noiselvls) + 0.5), col = "black", lty = 6)

axis(1, c(3, 11, 19, 28, 36)+1,
     c("epiNEM", "B-NEM", "NEM", "PC Algorithm", "ARACNE"),
     tick = FALSE, pos = -25)

accframe2 <- as.data.frame(
    cbind(data.frame(epiNEM = acc2[1,,]),
          data.frame(BNEM = acc2[2,,]), data.frame(NEM = acc2[3,,]),
          data.frame(Cor = acc2[4,,]), data.frame(MI = acc2[5,,])))

colnames(accframe2) <- rep(noiselvls, 5)

boxplot(accframe2, col = colvec,
                   main = "accuracy of the inferred edges", ylim = c(0,1))

abline(v=(1:(length(do)-1)*length(noiselvls) + 0.5), col = "black", lty = 6)

axis(1, c(3, 11, 19, 28, 36)+1,
     c("epiNEM", "B-NEM", "NEM", "PC Algorithm", "ARACNE"),
     tick = FALSE, pos = -0.2)

## logical nems:

colvec2 <- c(rep("orange", length(noiselvls)), rep("blue", length(noiselvls)))

logicsframe <- as.data.frame(cbind(data.frame(epiNEM = logics[1,,]),
                                   data.frame(BNEM = logics[2,,])))

colnames(logicsframe) <- rep(noiselvls, 2)

boxplot(logicsframe, col = colvec2,
        main = "accuracy of the inferred logic gate",
        ylim = c(0,1))

abline(v=length(noiselvls)+0.5, col = "black", lty = 6)

axis(1, c(3, 11, 19, 28, 36)+1,
     c("epiNEM", "B-NEM", "NEM", "PC Algorithm", "ARACNE"),
     tick = FALSE, pos = -0.2)

accframe <- as.data.frame(cbind(data.frame(epiNEM = acc[1,,]),
                                data.frame(BNEM = acc[2,,])))

colnames(accframe) <- rep(noiselvls, 2)

boxplot(accframe, col = colvec2,
        main = "accuracy of the inferred expected data",
        ylim = c(0,1))

abline(v=length(noiselvls)+0.5, col = "black", lty = 6)

axis(1, c(3, 11, 19, 28, 36)+1,
     c("epiNEM", "B-NEM", "NEM", "PC Algorithm", "ARACNE"),
     tick = FALSE, pos = -0.2)
```

## Yeast knockout screens

In this section we analyse previously published yeast knockout
screens. The screens consist of gene expression data derived from
double and single knockout mutants. We use epiNEM on each double
mutant combined with each single mutant.

The results (logics) of the knockout screens have been annotated
according to the following legend, where the x-axis denotes the
effect on the gene and the y-axis denotes the type of knock-out:

```{r, warning=FALSE, fig.width = 9, fig.height=5}
a1 <- HeatmapOP(matrix(c(1,-1,1,-1,1,1, 1, 1, 1), 3, 3,
                 dimnames = list(c("A", "B", "A.B"), LETTERS[1:3])),
                 Colv = FALSE, Rowv = FALSE,
          main = "OR", col = "Greys", sub = "", colorkey = NULL)
a2 <- HeatmapOP(matrix(c(1,-1,1,-1,1,1, -1, -1, 1), 3, 3,
                 dimnames = list(c("A", "B", "A.B"), LETTERS[1:3])),
                 Colv = FALSE, Rowv = FALSE,
          main = "AND", col = "Greys", sub = "", colorkey = NULL)
a3 <- HeatmapOP(matrix(c(1,-1,1,-1,1,1, 1, -1, -1), 3, 3,
                 dimnames = list(c("A", "B", "A.B"), LETTERS[1:3])),
                 Colv = FALSE, Rowv = FALSE,
          main = "B masks effect of A", col = "Greys", sub = "",
          colorkey = NULL)
a4 <- HeatmapOP(matrix(c(1,-1,1,-1,1,1, -1, 1, -1), 3, 3,
                 dimnames = list(c("A", "B", "A.B"), LETTERS[1:3])),
                 Colv = FALSE, Rowv = FALSE,
          main = "A masks effect of B", col = "Greys", sub = "",
          colorkey = NULL)
a5 <- HeatmapOP(matrix(c(1,-1,1,-1,1,1, 1, 1, -1), 3, 3,
                 dimnames = list(c("A", "B", "A.B"), LETTERS[1:3])),
                 Colv = FALSE, Rowv = FALSE,
          main = "XOR", col = "Greys", sub = "", colorkey = NULL)
a6 <- HeatmapOP(matrix(c(1,-1,1,-1,1,1, -1, 1, 1), 3, 3,
                 dimnames = list(c("A", "B", "A.B"), LETTERS[1:3])),
                 Colv = FALSE, Rowv = FALSE,
          main = "No epistasis", col = "Greys", sub = "", colorkey = NULL)
a7 <- HeatmapOP(matrix(c(1,-1,1,-1,1,1, 1, -1, 1), 3, 3,
                 dimnames = list(c("A", "B", "A.B"), LETTERS[1:3])),
                 Colv = FALSE, Rowv = FALSE,
          main = "No epistasis", col = "Greys", sub = "", colorkey = NULL)
a8 <- HeatmapOP(matrix(c(1,-1,1,-1,1,1, -1, -1, -1), 3, 3,
                 dimnames = list(c("A", "B", "A.B"), LETTERS[1:3])),
                 Colv = FALSE, Rowv = FALSE,
          main = "No epistasis (unconnected)", col = "Greys", sub = "",
          colorkey = NULL)
print(a5, position = c(0,0, .25, .5), more = TRUE)
print(a6, position = c(.25,0, .5, .5), more = TRUE)
print(a7, position = c(.5,0, .75, .5), more = TRUE)
print(a8, position = c(.75,0, 1, .5), more = TRUE)
print(a1, position = c(0,.5, .25, 1), more = TRUE)
print(a2, position = c(.25,.5, .5, 1), more = TRUE)
print(a3, position = c(.5,.5, .75, 1), more = TRUE)
print(a4, position = c(.75,.5, 1, 1))
```

### Wageningen et al., 2010

The first knock-out screen is from van Wageningen et al., 2010 and
was created to investigate relationships between phosphorylation based pathways.

Each figure visualizes the top scoring single knock-out or modulators
for a specific double knock-out pair. The x-axis corresponds to the
ranks of the single knock-outs and the y-axsis to the likelihood for
each triple (double plus single knock-outs).

The final figure shows the global distribution of the top scoring
logics we identified.

We load and preprocess the data set.

```{r}
file <- paste("http://www.holstegelab.nl/",
              "publications/sv/signaling_redundancy/downloads/DataS1.txt",
              sep = "")

data <- read.delim(file)

dataM <- data[-(1:2), (1+(1:(324/2))*2)]

dataP <- data[-(1:2), (2+(1:(324/2))*2)]

dataM <- dataM[-1, ]

dataP <- dataP[-1, ]

dataM <- apply(dataM, c(1,2), as.numeric)

dataP <- apply(dataP, c(1,2), as.numeric)

dataBin <- dataM

sig <- 0.05

cutoff <- log2(1.7)

dataBin[which(dataP < sig & dataP > 0 & abs(dataM) >= cutoff)] <- 1

dataBin[which(dataP >= sig | dataP == 0 | abs(dataM) < cutoff)] <- 0

dataBin <- dataBin[-which(apply(dataBin, 1, max) == 0), ]

dataBinWag <- dataBin

colnames(dataBin) <- gsub(".del.vs..wt", "", colnames(dataBin))

colnames(dataBin) <- gsub(".del", "", colnames(dataBin))

doubles <- colnames(dataBin)[grep("\\.", colnames(dataBin))]

if (length(grep("vs", doubles)) > 0) {
    doubles <- sort(doubles[-grep("vs", doubles)])
} else { doubles <- sort(doubles) }

doubles.genes <- unique(unlist(strsplit(doubles, "\\.")))

if (length(grep("\\.", colnames(dataBin))) > 0) {
    singles <- colnames(dataBin)[-grep("\\.", colnames(dataBin))]
} else { singles <- sort(singles) }

singles <- unique(sort(singles))
```

We apply epiNEM so all triples and infer logics and calculate the
log-likelihood.

```{r, eval=FALSE}
wagscreen <- epiScreen(dataBin)

doubles <- wagscreen$doubles,
singles <- wagscreen$singles
llmat <- wagscreen$llmat
logicmat <- wagscreen$logicmat
```

We plot the significant results for all triples with log-likelihoods
on the y-axis and ranked triples on the x-axis.

```{r, fig.width = 8, fig.height = 4}
palette(c("#4444cc", "#77aa77", "#009933",
          "#ff0000", "#dd8811", "#aa44bb", "#999900"))

data(wageningen)

llmat0 <- wageningen$ll

logicmat0 <- wageningen$logic

for (i in 1:length(doubles)) {
    
    if (i %in% 8) { next() }

    logicvec <- logicmat0[, i]

    llvec <- llmat0[, i]

    logicvec <- logicvec[order(llvec, decreasing = TRUE)]

    llvec <- llvec[order(llvec, decreasing = TRUE)]

    parents <- unlist(strsplit(doubles[i], "\\."))

    pchvec <- numeric(length(llvec))

    pchvec[which(logicvec %in% "AND")] <- 1
    pchvec[which(logicvec %in% "OR")] <- 2
    pchvec[which(logicvec %in% "XOR")] <- 3
    pchvec[grep(paste("^", parents[1], sep = ""), logicvec)] <- 4
    pchvec[grep(paste("^", parents[2], sep = ""), logicvec)] <- 5
    pchvec[which(logicvec %in% "NOEPI")] <- 6
    pchvec[which(logicvec %in% c("NOINFO", "NOINF"))] <- 7
    
    logicvec <- logicvec[-which(logicvec %in% "0")]
    pchvec <- pchvec[-which(pchvec == 0)]
    llvec <- llvec[-which(llvec == 0)]

    colvec <- pchvec
    
    if (all(is.infinite(llvec) == TRUE)) {

        llvec[1:length(llvec)] <- -1000

        margin <- 100

        donames <- 30

    } else {
        
        llvec[which(is.infinite(llvec) == TRUE)] <- NA
        
        ## llvec[which(is.infinite(llvec) == TRUE)] <- min(llvec) - 100
        
        margin <- abs(max(llvec[1:30], na.rm = TRUE) -
                  min(llvec[1:30], na.rm = TRUE))

        offset <- 0.075

        if (margin == 0) { margin <- 10; offset <- 0.0375 }

        donames <- 30 - sum(is.na(llvec[1:30]) == TRUE)

        if (any(is.na(llvec[1:30]) == TRUE)) { margin2 <- margin*2
        } else { margin2 <- margin }
        
        llvec[which(is.na(llvec) == TRUE)] <- min(llvec, na.rm = TRUE) - margin
        
        margin <- margin2

    }

    if (all(llvec[-(1:30)] - min(llvec[-(1:30)]) == 0)) {

        p2max <- max(llvec[-(1:30)]) + margin

    } else {

        p2max <- max(llvec[-(1:30)])
        
    }
    
    mark <- ""
    thetop <- sum(!(logicvec %in% c("NOINFO", "NOINF")))
    legendx <- length(llvec[1:thetop])
    p2max <- max(llvec[1:thetop])
    if (p2max == min(llvec[1:thetop])) {
        p2max <- p2max+margin*0.2
    }
    legendtext <- c("AND", "OR", "XOR",
                    paste(parents[1]," masks ", parents[2], sep = ""),
                    paste(parents[2], " masks ", parents[1], sep = ""),
                    "no epistasis")
    if (thetop == 0) { next() }
    plot = plot(llvec[1:thetop], pch = pchvec[1:thetop], col = colvec[1:thetop],
                ylab = "likelihood", xlab = "ranked single knockouts",
                ylim = c(min(llvec[1:thetop]), max(llvec[1:thetop])+margin*0.2),
                xlim = c(1, thetop+(thetop/100)),
                main = paste(unlist(strsplit(doubles[i], "\\.")),
                collapse = " and "))
    text = text((1:thetop)+(thetop/100), llvec[1:thetop]+(margin*offset),
                labels = names(llvec)[1:thetop], cex = 0.6, srt = 45, pos = 3,
                offset = 0)
    mtext = mtext(mark, side = 3, line = 1, outer = FALSE, cex = 4, adj = 0)
    legend = legend(legendx, p2max,
                    legend = legendtext,
                    col = 1:6, pch = 1:6, xjust = 1, yjust = 1, cex = 0.7)
    
}

distmat <- wageningen$logic

distmat[which(distmat %in% "AND")] <- 1
distmat[which(distmat %in% "OR")] <- 2
distmat[which(distmat %in% "XOR")] <- 3
distmat[which(distmat %in% "NOEPI")] <- 6
distmat[which(distmat %in% c("NOINFO", "NOINF"))] <- 7

for (i in 1:ncol(distmat)) {

    genes <- unlist(strsplit(colnames(distmat)[i], "\\."))
    
    distmat[which(distmat[, i] %in%
                  paste(genes[1], " masks the effect of ", genes[2],
                  sep = "")), i] <- 4

    
    distmat[which(distmat[, i] %in%
                  paste(genes[2], " masks the effect of ", genes[1],
                  sep = "")), i] <- 5

}

distmat <- apply(distmat, c(1,2), as.numeric)

for (i in 1:ncol(distmat)) {
    distmat[, i] <- rev(sort(distmat[, i]))
}

distmat <- distmat[-which(apply(distmat, 1, sum) == 0), ]

distmat <-
    distmat[, -which(apply(distmat, 2, max) == 0 | apply(distmat, 2, min) == 7)]

y <- distmat

distmat <-
    distmat[, order(apply(distmat, 2, function(x) { return(sum(x == 1)) }))]

y[which(y == 5)] <- 4

rownames(distmat) <- NULL

labeltext <- c("", "no information\n\n\n", "no epistasis\n\n\n",
              "masking (NOT B)\n\n\n",
              "masking (NOT A)\n\n\n", "XOR\n\n\n", "OR\n\n\n", "AND\n\n\n")

HeatmapOP(distmat, Colv = FALSE, Rowv = FALSE, main = "logic gate distribution",
          sub = "", col = "Paired", breaks = seq(0.5,7.5, length.out = 8),
          cexRow = 0, cexCol = 0.4, aspect = "fill",
          colorkey = list(space = "right",
                          labels = rev(labeltext), width = 1,
                          at = seq(1.5,7.5, length.out = 8)),
          xlab = "double knock-outs",
          ylab = "modulators\n(different order for each pair)",
          xrot = 45, bordercol = "transparent")
```

### Sameith et al., 2015

The second knock-out screen by Sameith et al., 2015 was created to
investigate growth based genetic interactions.

Again we preprocess the data.

```{r}
file <- paste("http://www.holstegelab.nl/",
"publications/GSTF_geneticinteractions/",
"downloads/del_mutants_limma.txt", sep = "")

data <- read.delim(file)

data <- apply(data, c(1,2), as.character)

dataM <- data[-1, which(data[1, ] %in% "M")]

dataM <- apply(dataM, c(1,2), as.numeric)

dataP <- data[-1, which(data[1, ] %in% "p.value")]

dataP <- apply(dataP, c(1,2), as.numeric)

dataBin <- dataM

sig <- 0.01

cutoff <- log2(1.5)

dataBin[which(dataP < sig & dataP > 0 & abs(dataM) >= cutoff)] <- 1

dataBin[which(dataP >= sig | dataP == 0 | abs(dataM) < cutoff)] <- 0

dataBin <- dataBin[-which(apply(dataBin, 1, max) == 0), ]

colnames(dataBin) <- gsub("\\.\\.\\.", "\\.", colnames(dataBin))

doubles <- colnames(dataBin)[grep("\\.", colnames(dataBin))]

if (length(grep("vs", doubles)) > 0) {
    doubles <- sort(doubles[-grep("vs", doubles)])
} else { doubles <- sort(doubles) }

doubles.genes <- unique(unlist(strsplit(doubles, "\\.")))

if (length(grep("\\.", colnames(dataBin))) > 0) {
    singles <- colnames(dataBin)[-grep("\\.", colnames(dataBin))]
} else { singles <- sort(singles) }

singles <- unique(sort(singles))
```

We apply epiNEM to screen all triples from double and single
knock-out combinations.

```{r, eval=FALSE}
samscreen <- epiScreen(dataBin)

doubles <- samscreen$doubles
singles <- samscreen$singles
logicmat <- samscreen$logicmat
llmat <- samscreen$llmat
```

We plot the significant results for all triples with
log-likelihoods on the y-axis and ranked triples on the x-axis.

```{r, fig.width = 8, fig.height = 4}
data(sameith)

llmat0 <- sameith$ll

logicmat0 <- sameith$logic

for (i in 1:length(doubles)) {
  
  logicvec <- logicmat0[, i]

  llvec <- llmat0[, i]

  logicvec <- logicvec[order(llvec, decreasing = TRUE)]

  llvec <- llvec[order(llvec, decreasing = TRUE)]

  parents <- unlist(strsplit(doubles[i], "\\."))

  pchvec <- numeric(length(llvec))

    pchvec[which(logicvec %in% "AND")] <- 1
    pchvec[which(logicvec %in% "OR")] <- 2
    pchvec[which(logicvec %in% "XOR")] <- 3
    pchvec[grep(paste("^", parents[1], sep = ""), logicvec)] <- 4
    pchvec[grep(paste("^", parents[2], sep = ""), logicvec)] <- 5
    pchvec[which(logicvec %in% "NOEPI")] <- 6
    pchvec[which(logicvec %in% c("NOINFO", "NOINF"))] <- 7

    logicvec <- logicvec[-which(logicvec %in% "0")]
    pchvec <- pchvec[-which(pchvec == 0)]
    llvec <- llvec[-which(llvec == 0)]

    colvec <- pchvec

    if (all(is.infinite(llvec) == TRUE)) {

        llvec[1:length(llvec)] <- -1000

        margin <- 100

        donames <- 30

    } else {
        
        llvec[which(is.infinite(llvec) == TRUE)] <- NA
        
        margin <- abs(max(llvec[1:30], na.rm = TRUE) - min(llvec[1:30],
                      na.rm = TRUE))

        if (margin == 0) { margin <- 10 }

        donames <- 30 - sum(is.na(llvec[1:30]) == TRUE)

        if (any(is.na(llvec[1:30]) == TRUE)) { margin2 <- margin*2
        } else { margin2 <- margin }
        
        llvec[which(is.na(llvec) == TRUE)] <- min(llvec, na.rm = TRUE) - margin
        
        margin <- margin2

    }

    if (all(llvec[-(1:30)] - min(llvec[-(1:30)]) == 0)) {

        p2max <- max(llvec[-(1:30)]) + margin

    } else {

        p2max <- max(llvec[-(1:30)])
        
    }
    
    labeltext <- c("AND", "OR", "XOR", paste(parents[1], " masks ",
                   parents[2], sep = ""),
                   paste(parents[2], " masks ", parents[1], sep = ""),
                   "no epistasis")

    mark <- ""
    pointx <- 10000
    thetop <- sum(!(logicvec %in% c("NOINFO", "NOINF")))
    legendx <- length(llvec[1:thetop])
    p2max <- max(llvec[1:thetop])
    if (p2max == min(llvec[1:thetop])) {
        p2max <- p2max+margin*0.2
    }
    if (thetop == 0) { next() }
    plot = plot(llvec[1:thetop], pch = pchvec[1:thetop], col = colvec[1:thetop],
                ylab = "likelihood", xlab = "ranked single knockouts",
                ylim = c(min(llvec[1:thetop]), max(llvec[1:thetop])+margin*0.2),
                xlim = c(1, thetop+(thetop/100)),
                main = paste(tolower(unlist(strsplit(doubles[i], "\\."))),
                             collapse = " and "))
    text = text((1:thetop)+(thetop/100), llvec[1:thetop]+(margin*offset),
                labels = tolower(names(llvec)[1:thetop]), cex = 0.6, srt = 45,
                pos = 3,
                offset = 0)
    mtext = mtext(mark, side = 3, line = 1, outer = FALSE, cex = 4, adj = 0)
    legend = legend(legendx, p2max,
                    legend = labeltext, col = 1:6, pch = 1:6, xjust = 1,
                    yjust = 1,
                    cex = 0.7)  
    
}

distmat <- sameith$logic

distmat[which(distmat %in% "AND")] <- 1
distmat[which(distmat %in% "OR")] <- 2
distmat[which(distmat %in% "XOR")] <- 3
distmat[which(distmat %in% "NOEPI")] <- 6
distmat[which(distmat %in% c("NOINFO", "NOINF"))] <- 7

for (i in 1:ncol(distmat)) {

    genes <- unlist(strsplit(colnames(distmat)[i], "\\."))
    
    distmat[which(distmat[, i] %in% paste(genes[1], " masks the effect of ",
                                          genes[2], sep = "")), i] <- 4

    
    distmat[which(distmat[, i] %in% paste(genes[2], " masks the effect of ",
                                          genes[1], sep = "")), i] <- 5

}

distmat <- apply(distmat, c(1,2), as.numeric)

for (i in 1:ncol(distmat)) {
    distmat[, i] <- rev(sort(distmat[, i]))
}

distmat <- distmat[-which(apply(distmat, 1, sum) == 0), ]

y <- distmat

distmat <- distmat[, order(apply(distmat, 2, function(x) {
                           return(sum(x == 1)) }))]

y[which(y == 5)] <- 4

rownames(distmat) <- NULL

labeltext <- c("", "no information\n\n\n", "no epistasis\n\n\n",
               "masking (NOT B)\n\n\n", "masking (NOT A)\n\n\n",
               "XOR\n\n\n", "OR\n\n\n", "AND\n\n\n")

HeatmapOP(distmat, Colv = FALSE, Rowv = FALSE,
          main = "logic gate distribution", sub = "",
          col = "Paired", breaks = seq(0.5,7.5, length.out = 8), cexRow = 0,
          cexCol = 0.4, aspect = "fill",
          colorkey = list(space = "right", labels = rev(labeltext), width = 1,
                          at = seq(1.5,7.5, length.out = 8)),
          xlab = "double knock-outs",
          ylab = "modulators\n(different order for each pair)",
          xrot = 45, bordercol = "transparent")
```

We plot the densities of the string-db interaction scores of our
identified modulators and a random draw to visualize the significance
of the interaction identified by epiNEM.

```{r, fig.width = 8, fig.height = 4}
par(mfrow=c(1,2))

source("https://bioconductor.org/biocLite.R")

biocLite("STRINGdb")

library(STRINGdb)

get_STRING_species(version="10", species_name=NULL)[26, ] # 4932

string_db <- STRINGdb$new( version="10", species=4932, score_threshold=0,
                          input_directory="~/")

llmat <- wageningen$ll

logicmat <- wageningen$logic

string.scores <- list()

string.names <- character()
```
```{r, eval=FALSE}
for (i in 1:ncol(llmat)) {

    if (sum(!(llmat[, i] %in% c(0,-Inf))) > 0) { 
        top30 <- llmat[, i]
        top30[which(top30 == 0)] <- -Inf
        top30 <- top30[which(!(llmat[, i] %in% c(0,-Inf)))]
        top30 <- top30[order(top30,decreasing = TRUE)[1:min(30, sum(!(llmat[, i]
            %in% c(0,-Inf))))]]

        doubles <- unlist(strsplit(colnames(llmat)[i], "\\."))

        for (j in names(top30)) {
            tmp <- string_db$get_interactions(string_db$mp(c(doubles[1], j)))
            string.scores <- c(string.scores, tmp$combined_score)
            string.names <- c(string.names, paste(sort(c(doubles[1], j)),
                                                  collapse = "_"))
            tmp <- string_db$get_interactions(string_db$mp(c(doubles[2], j)))
            string.scores <- c(string.scores, tmp$combined_score)
            string.names <- c(string.names, paste(sort(c(doubles[2], j)),
                                                  collapse = "_"))
        }
        
    } else {
        next()
    }

}
```
```{r, fig.width = 8, fig.height = 5}
data(wageningen_string)

string.scores <- wageningen_string$string.scores
string.names <- wageningen_string$string.names

tmp <- string_db$get_interactions(
       string_db$mp(unique(unlist(strsplit(colnames(dataBinWag), "\\.")))))

stsc <- unlist(string.scores)

denspval <- wilcox.test(stsc, unlist(tmp$combined_score),
            alternative = "greater")$p.value

for (i in 100:1) {

    if (denspval < 10^(-i)) {

        denspval <- paste("< ", 10^(-i), sep = "")

    } 

}

plot(density(stsc), col = "#00000000",
     ylim = c(0, max(c(max(density(stsc)$y),
     max(density(unlist(tmp$combined_score))$y)))),
     main = paste("Mann-Whitney test p-value ", denspval, sep = ""), xlab = "",
     cex.main = 1.5)
polygon(density(stsc), col = "#ff000066")

lines(density(unlist(tmp$combined_score)), col = "#00000000")
polygon(density(unlist(tmp$combined_score)), col = "#00ffff66")

llmat <- sameith$ll

logicmat <- sameith$logic

string.scores2 <- list()

string.names2 <- character()
```
```{r, eval=FALSE}
for (i in 1:ncol(llmat)) {

    if (sum(!(llmat[, i] %in% c(0,-Inf))) > 0) { 
        top30 <- llmat[, i]
        top30[which(top30 == 0)] <- -Inf
        top30 <- top30[which(!(llmat[, i] %in% c(0,-Inf)))]
        top30 <- top30[order(top30, decreasing = TRUE)[1:min(30,
        sum(!(llmat[, i] %in% c(0,-Inf))))]]

        doubles <- unlist(strsplit(colnames(llmat)[i], "\\."))

        for (j in names(top30)) {
            tmp <- string_db$get_interactions(string_db$mp(c(doubles[1], j)))
            string.scores2 <- c(string.scores2, tmp$combined_score)
            string.names2 <- c(string.names2, paste(sort(c(doubles[1], j)),
            collapse = "_"))
            tmp <- string_db$get_interactions(string_db$mp(c(doubles[2], j)))
            string.scores2 <- c(string.scores2, tmp$combined_score)
            string.names2 <- c(string.names2, paste(sort(c(doubles[2], j)),
            collapse = "_"))
        }
        
    } else {
        next()
    }

}
```
```{r, fig.width = 8, fig.height = 5}
data(sameith_string)

string.scores2 <- sameith_string$string.scores2
string.names2 <- sameith_string$string.names2

tmp <- string_db$get_interactions(
       string_db$mp(unique(unlist(strsplit(colnames(dataBin), "\\.")))))

stsc <- unlist(string.scores2)

denspval <- wilcox.test(stsc, unlist(tmp$combined_score),
            alternative = "greater")$p.value

for (i in 100:1) {

    if (denspval < 10^(-i)) {

        denspval <- paste("< ", 10^(-i), sep = "")

    } 

}

plot(density(stsc), col = "#00000000",
     ylim = c(0, max(c(max(density(stsc)$y),
     max(density(unlist(tmp$combined_score))$y)))),
     main = paste("Mann-Whitney test p-value ", denspval, sep = ""), xlab = "",
     cex.main = 1.5)
polygon(density(stsc), col = "#ff000066")

lines(density(unlist(tmp$combined_score)), col = "#00000000")
polygon(density(unlist(tmp$combined_score)), col = "#00ffff66")
```

```{r}
sessionInfo()
```

*__Reference:__*

Martin Pirkl, Madeline Diekmann, Marlies van der Wees, Niko Beerenwinkel,
Holger Fröhlich, Florian Markowetz. Inferring Modulators of Genetic
Interactions with Epistatic Nested Effects Models. submitted.

Margolin AA, Nemenman I, Basso K, Wiggins C, Stolovitzky G, {Dalla Favera} R,
et~al. ARACNE: an algorithm for the reconstruction of gene regulatory networks
in a mammalian cellular context. BMC Bioinformatics. 2006;7 Suppl 1:S7.

Kalisch M, B\"{u}hlmann P. Estimating High-Dimensional Directed Acyclic Graphs
with the PC-Algorithm. J Mach Learn Res. 2007;8.

Markowetz F, Bloch J, Spang R. Non-transcriptional pathway features
reconstructed from secondary effects of RNA interference. Bioinformatics.
2005;21(21):4026--4032.

Pirkl M, Hand E, Kube D, Spang R. Analyzing synergistic and non-synergistic
interactions in signalling pathways using Boolean Nested Effect Models.
Bioinformatics. 2016;32(6):893--900.

van Wageningen S, Kemmeren P, Lijnzaad P, Margaritis T, Benschop JJ,
de Castro IJ, et~al. Functional overlap and regulatory links shape genetic
interactions between signaling pathways. Cell. 2010 Dec;143(6):991--1004.

Sameith K, Amini S, Groot~Koerkamp MJA, van Leenen D, Brok M, Brabers N, et~al.
A high-resolution gene expression atlas of epistasis between gene-specific
transcription factors exposes potential mechanisms for genetic interactions.
BMC biology. 2015 Dec;13:112.

