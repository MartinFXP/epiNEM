% SUPPLEMENTARY MATERIAL
% !Rnw weave = knitr
% -*-coding:latin-1-*-
\RequirePackage{fix-cm}

\documentclass[paper=a4,notitlepage,DIV=12]{scrartcl}
\pdfminorversion=4 % needed to ensure PDF version 1.4 for Journal tools
\usepackage{siunitx}
\usepackage{fixltx2e}
\usepackage{setspace}
\usepackage{array}
\newcolumntype{L}[1]{>{\raggedright\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
\usepackage{lineno}
\usepackage{amsmath}
\usepackage{amsfonts}
%\usepackage{amsthm}
\usepackage{graphicx}
\usepackage{latexsym}
\usepackage[numbers,sort&compress]{natbib}
\citestyle{nature}
\usepackage{nomencl}
%\usepackage{svninfo}
\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage[activate={true,nocompatibility},final,tracking=true,kerning=true,spacing=true,factor=1100,stretch=10,shrink=10]{microtype}
\usepackage{textcomp}
\usepackage{eurosym}
\usepackage{upgreek}
\usepackage{setspace}
\usepackage{gensymb}
\usepackage[colorinlistoftodos,disable]{todonotes} % disable 
\usepackage{hyperref}
\newcommand{\g}[1]{\emph{#1}}

\makenomenclature
\let\nc\nomenclature

\newcommand{\piqe}{\left(\pi_0 \ Q \ e^{tQ}\right)_i}
\newcommand{\piqqe}{\left(\pi_0 \ Q^2 \ e^{tQ}\right)_i}
\newcommand{\pie}{\left(\pi_0 \ e^{tQ}\right)_i}

\newcommand{\field}[1]{\mathbb{#1}}
\newcommand{\C}{\field{C}}
\newcommand{\R}{\field{R}}
\newcommand{\N}{\field{N}}
\newcommand{\Q}{\field{Q}}
\newcommand{\A}{\ifmmode{\field{A}}      \else{$\field{A}$}\fi}
\renewcommand{\P}{\field{P}}

\DeclareMathOperator*{\argmax}{argmax}
\DeclareMathOperator*{\Var}{Var}
\DeclareMathOperator*{\modell}{Modell}
\DeclareMathOperator*{\rang}{rang}
\DeclareMathOperator*{\Mn}{\ifmmode{{\bf M(n;\R) }}\else{$\bf M(n;\R)  $}\fi}
\DeclareMathOperator*{\cof}{cof}
\DeclareMathOperator*{\adj}{Adj}
\DeclareMathOperator*{\tr}{tr}
\DeclareMathOperator*{\EMP}{{\boldmath EMP}}
\graphicspath{{../figures/}}

%% florian added:
%\usepackage[usenames,dvipsnames]{xcolor}
\usepackage{color}
%\newcommand{\todo}[1]{\textbf{\color{red} #1}}
\newcommand{\fm}[1]{{\color{BlueGreen} #1}}
\newcommand{\revised}[1]{{\color{blue} #1}}
\definecolor{gray}{rgb}{0.6,0.6,0.6}
\newcommand{\texttext}{\emph{\color{gray}`Twas brillig, and the slithy
toves/ Did gyre and gimble in the wabe:/ All mimsy were the
borogoves,/ And the mome raths outgrabe./ "Beware the Jabberwock, my
son!/ The jaws that bite, the claws that catch!/ Beware the Jubjub
bird, and shun/ The frumious Bandersnatch!"}}


%% roland added:
\usepackage{rotating}
\usepackage{multirow}
\newcommand{\InsertLandscapeTable}[4]{
  \begin{sidewaystable}[!htbp]
    \begin{center}
      \leavevmode
      #4
      \caption[#1]{#1 #2}
      \label{#3}
    \end{center}
  \end{sidewaystable}}

\newcommand{\nomargin}{\vspace{-2.7cm}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\title{Combinatorial Nested Effects Models}

\date{\today}
\begin{document}

<<include=FALSE, message = FALSE>>=
opts_chunk$set(concordance=TRUE)
@

\maketitle
%\noindent$^1$ Cancer Research UK Cambridge Institute, Li Ka Shing Centre, Cambridge, CB2 0RE, UK\\
%$^2$ Department of Oncology, University of Cambridge, Hutchison/MRC Research Centre, Hills Road, Cambridge, CB2 0XZ, UK\\
%$^3$ Cambridge University Hospitals NHS Foundation Trust, Cambridge Biomedical Campus, Hills Road, Cambridge, CB2 0QQ, UK\\
%$^4$ University Department of Radiology, Box 218, Level 5, Addenbrooke's Hospital, Hills Road, Cambridge, CB2 2QQ, UK\\
%$^\dagger$ Current affiliations: RFS, European Bioinformatics Institute, Hinxton; CKYN, The Institute for Cancer Research, London; SLC, The Sanger Institute, Hinxton; SN, Department of Human Genetics, Emory University School of Medicine.\\

%\medskip
%\noindent$^*$ To whom correspondence should be addressed: florian.markowetz@cruk.cam.ac.uk,\\ james.brenton@cruk.cam.ac.uk\\
%\noindent Keywords: Intratumoral genetic heterogeneity, high-grade serous ovarian carcinoma, neoadjuvant chemotherapy, biomarker, array comparative genomic hybridization, next-generation sequencing


\thispagestyle{empty}
\tableofcontents
\listoftodos

\clearpage

%%
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{The package epiNEM}

This package is an extension of the classic Nested Effects Models provided in package \emph{nem}. Nested Effects Models is a pathway reconstruction method, which takes into account effects of downstream genes. Those effects are observed for every knockout of a pathway gene, and the nested structure of observed effects can then be used to reconstruct the pathway structure.
However, classic Nested Effects Models do not account for double knockouts. In this package \emph{epiNEM}, one additional layer of complexity is added. For every two genes, acting on one gene together, the relationship is evaluated and added to the model as a logic gate. Genetic relationships are represented by the logics OR (no relationship), AND (functional overlap), NOT (masking or inhibiting) and XOR (mutual prevention from acting on gene C).

\subsection{Core functions}

\paragraph{epiNEM()}
The main function \emph{epiNEM} can be called using several different parameters. First of all, a filename is specified, containing a table with binary data. If no such data available, \emph{random} needs to be specified. The vector \emph{random} consists of the number of single as well as double knockouts, the number of reporter (downstream) genes, the false positive and false negative rate and lastly the number of replicates. With all those parameter, a corresponding dataset is simulated.

Furthermore, the user can choose whether to perform exhaustive search or use Greedy Hill Climbing (recommended for network > 5 genes),whereas for the latter a number of iterations has to be set as well.

\paragraph{epiNEM.PlotResults()}
In order to plot the winning pathway structure, \emph{epiNEM.PlotResults} can be called. Its input is an object of epiNEM, containing information on the model structure, the introduced logics and its positions, the likelihood and the attachment of E-Genes.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
<<echo=FALSE, message=FALSE>>=
#library(epiNEM)
library(magrittr)
library(tidyr)
library(ggplot2)
library(data.table)
library(BoolNet)
library(igraph)
library(e1071)
library(grid)
library(org.Sc.sgd.db)
devtools::load_all()
library(dplyr)
@

\section{Validation studies}

\subsection{Comparing against other methods}

In this section, we compare epiNEMs against the classic Nested Effects Models, as well as against network reconstruction by using Correlation and Mutual Information. We performed 500 simulations of 3 node networks for different false negative rates. 

<<eval=FALSE>>==
simul500 <- epiNEM.Simulations(random, 500)
@

Those networks were then learned by the above mentioned methods. For each method, we plot the number of wrong edges for each false negative rate.

<<echo = FALSE, warning=FALSE>>==
listy <- rbind(simul500$errorLOG, simul500$errorNEM, simul500$errorCOR08, 
               simul500$errorMUT08)

color_list <- c(simul500$log, rep(0, 24))

lis <- data.table(log = unlist(listy[1,], recursive = FALSE), 
                  nem = unlist(listy[4,], recursive = FALSE),
                  mut = unlist(listy[2,], recursive = FALSE), 
                  cor = unlist(listy[3,], recursive = FALSE),
                  FNrate = rep(c(0.01, 0.025, 0.05, 0.1, 0.2, 0.3, 0.4, 0.5), 
                               each = 500, len = 4000))

lis2 <- gather(lis, variable, value, -FNrate)

lis3 <- lis2 %>% mutate(col = rep(color_list, each = 500))

ggplot(lis3, aes(x = interaction(FNrate, variable), y = value, fill = col)) +
  geom_boxplot() +
  scale_y_continuous(name = "number of incorrect edges") +
  scale_x_discrete(labels= as.vector(rep(unique(lis3$FNrate), 4)), 
                   name = "False negative rate") +
  geom_vline(xintercept=c(8.5, 16.5, 24.5 )) +
  annotate("text", x = 4, y = 7, label = "epiNEM") +
  annotate("text", x = 12, y = 7, label = "NEM") +
  annotate("text", x = 20.5, y = 7, label = "Mutual Information") +
  annotate("text", x = 28, y = 7, label = "Correlation") +
  scale_fill_continuous(guide = guide_legend(title = "correctly introduced logics"),
                        breaks = c(0,250, 382), label=c("0%", "50%", "75%")) +
  theme(legend.position = c(.12,.79)) +
  labs(title = "Reconstruction of 500 simulated 3-node networks for varying 
       false negative rates\n")
@



\section{Case Study}

\subsection{Data overview}

The data provided in this package is based on the study of van Wageningen [reference]. The dataset consists of in total 150 viable protein kinase and phosphatase perturbations, as well as 15 viable double knockouts. DNA microarray expression profiles were generated under a single growth condition. For each mutant, two independent cultures have been measured and p-values according to relative expression change as well as mutant/wildtype ratios recorded.
The raw data input consists of a matrix of p-values indicating the relative change of gene expression for each perturbation. The columns indicate gene deletions, the rows represent all downstream genes that were investigated for exhibiting effects.

\subsection{Running the main function}

First we load the R packages and load the example data file from \url{http://www.
holstegelab.nl/publications/sv/signaling_redundancy/}. The data file contains a gene expression matrix of all kinase phosphatase mutants. For the analysis, a small number of genes can be selected, which we specify in a 'genelist'.

<<message=FALSE>>=
#library(epiNEM)
library(magrittr)
library(tidyr)
library(ggplot2)
library(data.table)
library(BoolNet)
library(igraph)
library(e1071)
library(grid)
library(org.Sc.sgd.db)
devtools::load_all()
library(dplyr)
@

<<tidy=FALSE, message = FALSE>>=
## load data file from local copy or from URL
address <-
  "http://www.holstegelab.nl/publications/sv/signaling_redundancy/downloads/DataS1.txt"
data <- data.table(read.csv(url(address), sep="\t", header=TRUE))
genelist <- toupper(c('bck1', 'slt2', 'ptp2', 'bck1.slt2'))

## read in genes from user and prepare for further analysis
read_in_genes <- function(genes){
  return(unlist(lapply(genes, function(x) {paste(x, '.del.vs..wt.1', sep='')})))
}
single <- read_in_genes(genelist)
@

Also, we only consider changes in expression which result in a p-value < 0.05. All those are set to 1, the other ones to 0.

<<tidy=FALSE, message = FALSE>>=
## numericalize factors
as.numeric.factor <- function(x) {as.numeric(levels(x))[x]}
@

Last, we put all constraints together, meaning, we select and binarize the data.

<<tidy = FALSE, message = FALSE, cache = TRUE>>=
data %<>% dplyr::select(-c(systematicName, geneSymbol)) %>% 
  filter(-1) %>%
  mutate_each(funs(droplevels)) %>%
  mutate_each(funs(as.numeric.factor)) %>% 
  data.frame()

# consider foldchange and gene expression
# 0.73 = log2(1.7)
new <- matrix(0, ncol=dim(data)[2]/2, nrow=dim(data)[1])
colnames(new) <- colnames(data)[1:(dim(data)[2]/2)]
n=1
  for (i in seq(1, dim(data)[2], by=2)){
    colnames(new)[n] <- colnames(data)[i+1]
    for (k in 1:dim(data)[1]){
      if (((abs(data[k,i])) >= 0.76) & (data[k,i+1] < 0.05)) # & data[k,i+1] > 0))
        new[k,n] <- 1 
      else new[k,n] <- 0
    }
    n = n+1
  }
# filter out 0-rows and set new colnames
new3 <- data.table(new[,which(colSums(new)!=0)])
#new5 <- data.table(new3[which(rowSums(new3)!=0),])
new4 <- new3 %>% (function(x){setnames(x, names(x), toupper(names(x)) %>%
  gsub('.DEL.VS..WT.1', '', .) %>%
  gsub('.VS..WT', '',.) %>%
  gsub('.DEL.', '.', .)); return(x)})

mutants     <- names(new4)
experiments <- mutants[!grepl("\\.", mutants)]
dKO         <- mutants[which(!mutants %in% experiments)]
dKO         <- dKO[!grepl('\\..*\\.', dKO)]
sKO <- unlist(strsplit(dKO, ".", fixed=TRUE))

sKO_add <- sKO[which(!sKO %in% names(new4))]

for (i in 1:length(sKO_add)){
  new4[, sKO_add[i]] <- c(rep(0,dim(new4)[1]))
}

PWadd <- genelist[which(!genelist %in% names(new4))]
for( i in 1:length(PWadd)){
  new4[, PWadd[i]] <- c(rep(0, dim(new4)[1]))
}

pathwayData <- new4 %>%
  select_(.dots = genelist) %>%
  filter(rowSums(.) > 0)

# short glimpse of the data
head(pathwayData)
@

Rownames correspond to sample identifiers. Columns indicate the mutants. A 1 corresponds to a change in expression for an identifier at a knockdown, a 0 represents no effect.

An already processed version of the complete dataset is provided in this package and accessible by calling \emph{epiNEMdata}.

<<tidy=FALSE, cache=TRUE>>=
lognem <- epiNEM(filename=pathwayData, method = "exhaustive")  #, nIterations=3)
@

epiNEM introduces a logic gate for every node, which has exactly two parents. This logic gate represents the relationship of the parents, the interaction. If there is no interaction, as assumed in the classic NEMs, an OR-gate is introduced. Functional overlap of two genes is represented by an AND-gate, meaning both parents must be knocked out at the same time, in order for the signal to be interrupted. The logics NOTA and NOTB stand for a so called masking effect and the XOR-gate can be interpreted as some kind of mutual prevention of the parents from acting on the child gene.

The search space of epiNEM is now extended by those logic gates, and each model evaluated. Output of the algorithm is all information on the highest-scoring pathway structure.

<<tidy=FALSE, message = FALSE>>=
lognem <- unlist(lognem, recursive = FALSE)
lognem
@

\subsection{Plotting the result}

This winning pathway structure can further be visualized by the function PlotResults(), which is also available with the package epiNEM. The grey circles, which are attached to the genes, denote the number of E-genes attached to them. The unconnected circle includes all those, which could not uniquely be attached to a single S-gene.

<<tidy=FALSE, message = FALSE>>=
epiNEM.PlotResults(lognem)
@

\subsection{Triplet screening}

For analysing the mixed epistasis found by van Wageningen et. al., we constructed networks of only three nodes for every double knockout. Or, we combined each pair with any remaining gene and evaluate each of those small networks. Depending on the introduced logic, we were able to confirm most experimental results.
First we need to define the double knockout of interest -- in this example we choose ptp2 and ptp3 -- and combine it with all remaining single experiments in a vector called currentSet.

<<>>==
#  parents     <- 'PTP2.PTP3'
#  parents2    <- unlist(strsplit(parents, ".", fixed=TRUE))
#  mutants     <- names(full_matrix)
#  experiments <- mutants[!grepl("\\.", mutants)]
#  dKO         <- mutants[which(!mutants %in% experiments)]
#  dKO         <- dKO[!grepl('\\..*\\.', dKO)]
#  NOT2 <- paste(parents2[2], "masks the effect of", parents2[1])
#  NOT1 <- paste(parents2[1], "masks the effect of", parents2[2])
  
#  currentSet <- c(experiments, parents)
@
  
  We modify our dataset in a way that it only contains the double knockout of interest plus single knockouts. In addition, we keep a common E-Geneset for better overall comparison of our results. We keep all E-Genes showing effect in either single or double mutant in combination of interest. 

Then, we call epiNEM for every triple in the dataset.

<<cache=TRUE, warning=FALSE, error=FALSE>>==
mutants     <- names(new4)
experiments <- mutants[!grepl("\\.", mutants)]
dKO         <- mutants[which(!mutants %in% experiments)]
dKO         <- dKO[!grepl('\\..*\\.', dKO)]

#for(tri in 1:length(dKO)){
parents     <- dKO[5]
parents2    <- unlist(strsplit(parents, ".", fixed=TRUE))
NOT2 <- paste(parents2[2], "masks the effect of", parents2[1])
NOT1 <- paste(parents2[1], "masks the effect of", parents2[2])

currentSet <- c(experiments, parents)

trip_data   <- new4 %>% #tbl_df() %>%
    select_(., .dots = currentSet)

EGcols <- which(colnames(trip_data) %in% c(parents, parents2))

trip_data$ID <- as.numeric(rownames(trip_data))

## common EGeneset containing only E-genes that are affected at 
## either double or single mutant
EG <- trip_data %>%
   dplyr::select(EGcols, ID) %>%
   filter((rowSums(.)-ID) > 0)

EGdata <- as.data.frame(trip_data)[which(trip_data$ID %in% EG$ID),]

  scores <- c()
  singles <- experiments[which(!experiments %in% parents2)]
for (i in 1:(length(singles)-1)){
  mutants1    <- c(singles[i], parents2, parents)
  experiments1 <- mutants1[1:length(mutants1)-1]
  modelsTrip1 <- EnumerateModels(length(experiments1), experiments1)
  EGdata2     <- EGdata[,which(colnames(trip_data) %in% mutants1)]
  scores[[i]] <- epiNEM(filename = EGdata2, method = "exhaustive")
  #load('SAgain_scores6_12.RData')
}
@

<<echo=FALSE>>==
scores <- unlist(scores, recursive = FALSE)
NOT2 <- paste(parents2[2], "masks the effect of", parents2[1])
NOT1 <- paste(parents2[1], "masks the effect of", parents2[2])
cols <- as.vector(sapply(unlist(lapply(scores, function(x){x$logics}), recursive=FALSE), 
                         colours, parents2))
color <- as.vector(unlist(cols["col",], recursive=FALSE))
pchs <- as.vector(unlist(cols["pch",], recursive=FALSE))
log <- as.vector(unlist(cols["log",], recursive=FALSE))
@

And finally we can plot the marginal likelihood and the logic included for evaluation. In this example it shows clearly, that only AND-logic gates were introduced to every single model. This overlaps with the results from van Wageningen et. al. who found out experimentally, that ptp2 with ptp3 always behave in complete redundancy.

<<echo=FALSE>>==
x <- org.Sc.sgdGENENAME
mapped_genes <- mappedkeys(x)
xx <- as.list(x[mapped_genes])

namess = sort(unlist(lapply(scores, function(x){rownames(x$origModel)[which(!rownames(x$origModel) %in% parents2)] }), recursive=FALSE))
dat = sort(unlist(lapply(scores, function(x){x$score}), recursive=FALSE))

ggpdat <- dat %>%
  data.table(gene = namess[order(.,decreasing = T)], log_liklihood = .[order(.,decreasing = T)],
             colorz = color[order(.,decreasing = T)], logic = log[order(.,decreasing = T)])
ggpdat <- ggpdat %>% data.table(., index = 1:length(dat))
ggpdat <- ggpdat %>% select(-1)

color_list = unique(ggpdat$colorz)
labels_list = unique(ggpdat$logic)

annotate <- unlist(lapply(ggpdat$gene[1:5], function(x){getGeneName(x)}), recursive= FALSE)
annotate <- c(annotate, rep("", dim(ggpdat)[1]-5))

index = c(1,6,11,16,21, seq(26, dim(ggpdat)[1]+20))
ggpdat$index <- index

ggplot(data=ggpdat, aes(index, log_liklihood, colour=colorz)) + 
    geom_point() +
    scale_colour_manual(values=setNames(ggpdat$colorz, ggpdat$colorz)) +
  labs(title= paste(parents2[1], " and ", parents2[2], sep="")) +
  scale_size_manual(values = c(2,3,3)) +
  guides(size = F) +
  coord_cartesian(xlim = c(-1, 125), ylim = c(min(dat)-2, max(dat)+5)) +
  scale_y_continuous(#limits = c(-5,0),
    name = "Log Likelihood") +
  scale_x_discrete(breaks = c(1, ggpdat$index[dim(ggpdat)[1]]),
                   labels= c(1, dim(ggpdat)[1]), name = "Modulators") +
  #annotate(geom = "rect", xmin = -1, xmax = ggpdat$index[dim(ggpdat)[1]], ymin =  dat[length(dat)-4]-30, ymax = 0, alpha = .15 ) +
  geom_text(aes(label= annotate), size=6, angle = 45, hjust = 0) +
  theme(legend.position = c(.77,.75), legend.key.size = unit(2, "cm"),
        legend.text = element_text(size = 15), legend.title = element_text(size=16),
        plot.title = element_text(size = rel(2)))
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

        
%%
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\clearpage
\section{Session Info}
<<>>=
sessionInfo()
@

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% References
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\clearpage
\bibliographystyle{../manuscript/myvancouver}
\bibliography{../manuscript/cnv-distance}



\end{document}

